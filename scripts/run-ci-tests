#!/usr/bin/env bash

# Generic parallel CI test runner
# Supports both acceptance tests and migration tests
# Dynamically detects which services have sweeper implementations by grepping for AddTestSweepers

# ./internal/services/account
# account creation can only be done by a tenant admin and the current CI does 
# have that support.
# TODO: support tenant admin auth for acceptance tests

# List of services with their parallel test configuration
# Each service is defined as: resource=<path> parallel=<number>
# parallel=1 means sequential execution, parallel=0 means use default (GOMAXPROCS)
declare -a SERVICES=(
    "resource=./internal/services/account parallel=0"
    "resource=./internal/services/account_api_token_permission_groups parallel=0"
    "resource=./internal/services/account_dns_settings parallel=0"
    "resource=./internal/services/account_dns_settings_internal_view parallel=0"
    "resource=./internal/services/account_member parallel=0"
    "resource=./internal/services/account_permission_group parallel=0"
    "resource=./internal/services/account_role parallel=0"
    "resource=./internal/services/account_subscription parallel=0"
    "resource=./internal/services/account_token parallel=0"
    "resource=./internal/services/address_map parallel=0"
    "resource=./internal/services/api_shield parallel=0"
    "resource=./internal/services/api_token parallel=0"
    "resource=./internal/services/argo_smart_routing parallel=0"
    "resource=./internal/services/argo_tiered_caching parallel=0"
    "resource=./internal/services/authenticated_origin_pulls parallel=0"
    "resource=./internal/services/authenticated_origin_pulls_certificate parallel=0"
    "resource=./internal/services/byo_ip_prefix parallel=0"
    "resource=./internal/services/certificate_pack parallel=0"
    "resource=./internal/services/cloud_connector_rules parallel=0"
    "resource=./internal/services/custom_pages parallel=0"
    "resource=./internal/services/custom_ssl parallel=0"
    "resource=./internal/services/dns_record parallel=0"
    "resource=./internal/services/dns_settings_internal_view parallel=0"
    "resource=./internal/services/dns_zone_transfers_acl parallel=0"
    "resource=./internal/services/dns_zone_transfers_tsig parallel=0"
    "resource=./internal/services/email_routing_catch_all parallel=0"
    "resource=./internal/services/email_routing_dns parallel=0"
    "resource=./internal/services/email_routing_rule parallel=0"
    "resource=./internal/services/email_security_impersonation_registry parallel=0"
    "resource=./internal/services/email_security_trusted_domains parallel=0"
    "resource=./internal/services/ip_ranges parallel=0"
    "resource=./internal/services/list parallel=0"
    "resource=./internal/services/list_item parallel=1"
    "resource=./internal/services/load_balancer parallel=0"
    "resource=./internal/services/load_balancer_monitor parallel=0"
    "resource=./internal/services/load_balancer_pool parallel=0"
    "resource=./internal/services/logpull_retention parallel=0"
    "resource=./internal/services/logpush_job parallel=0"
    "resource=./internal/services/logpush_ownership_challenge parallel=0"
    "resource=./internal/services/magic_transit_connector parallel=0"
    "resource=./internal/services/magic_wan_ipsec_tunnel parallel=1"
    "resource=./internal/services/magic_wan_gre_tunnel parallel=1"
    "resource=./internal/services/magic_wan_static_route parallel=1"
    "resource=./internal/services/managed_transforms parallel=1"
    "resource=./internal/services/observatory_scheduled_test parallel=0"
    "resource=./internal/services/origin_ca_certificate parallel=0"
    "resource=./internal/services/page_rule parallel=0"
    "resource=./internal/services/pages_domain parallel=0"
    "resource=./internal/services/pages_project parallel=0"
    "resource=./internal/services/queue parallel=0"
    "resource=./internal/services/r2_bucket parallel=0"
    "resource=./internal/services/regional_tiered_cache parallel=0"
    "resource=./internal/services/ruleset parallel=0"
    "resource=./internal/services/spectrum_application parallel=0"
    "resource=./internal/services/tiered_cache parallel=0"
    "resource=./internal/services/turnstile_widget parallel=0"
    "resource=./internal/services/url_normalization_settings parallel=0"
    "resource=./internal/services/waiting_room_settings parallel=0"
    "resource=./internal/services/workers_cron_trigger parallel=0"
    "resource=./internal/services/workers_custom_domain parallel=0"
    "resource=./internal/services/workers_for_platforms_dispatch_namespace parallel=0"
    "resource=./internal/services/workers_kv_namespace parallel=0"
    "resource=./internal/services/workers_route parallel=0"
    "resource=./internal/services/workers_script parallel=0"
    "resource=./internal/services/zero_trust_access_application parallel=0"
    "resource=./internal/services/zero_trust_access_custom_page parallel=0"
    "resource=./internal/services/zero_trust_access_group parallel=0"
    "resource=./internal/services/zero_trust_access_identity_provider parallel=0"
    "resource=./internal/services/zero_trust_access_key_configuration parallel=0"
    "resource=./internal/services/zero_trust_access_mtls_certificate parallel=0"
    "resource=./internal/services/zero_trust_access_mtls_hostname_settings parallel=0"
    "resource=./internal/services/zero_trust_access_policy parallel=0"
    "resource=./internal/services/zero_trust_access_service_token parallel=0"
    "resource=./internal/services/zero_trust_access_short_lived_certificate parallel=0"
    "resource=./internal/services/zero_trust_access_tag parallel=0"
    "resource=./internal/services/zero_trust_device_custom_profile parallel=0"
    "resource=./internal/services/zero_trust_device_custom_profile_local_domain_fallback parallel=0"
    "resource=./internal/services/zero_trust_device_default_profile_certificates parallel=0"
    "resource=./internal/services/zero_trust_device_managed_networks parallel=0"
    "resource=./internal/services/zero_trust_dlp_custom_profile parallel=0"
    "resource=./internal/services/zero_trust_dlp_entry parallel=0"
    "resource=./internal/services/zero_trust_gateway_proxy_endpoint parallel=0"
    "resource=./internal/services/zero_trust_gateway_settings parallel=0"
    "resource=./internal/services/zero_trust_list parallel=0"
    "resource=./internal/services/zero_trust_organization parallel=0"
    "resource=./internal/services/zero_trust_tunnel_cloudflared parallel=0"
    "resource=./internal/services/zero_trust_tunnel_cloudflared_route parallel=0"
    "resource=./internal/services/zero_trust_tunnel_cloudflared_token parallel=0"
    "resource=./internal/services/zone parallel=0"
    "resource=./internal/services/zone_cache_reserve parallel=0"
    "resource=./internal/services/zone_cache_variants parallel=0"
    "resource=./internal/services/zone_hold parallel=0"
    "resource=./internal/services/zone_lockdown parallel=0"
    "resource=./internal/services/zone_setting parallel=0"
    "resource=./internal/services/zone_subscription parallel=0"
)

# Helper function to parse service configuration
parse_service_config() {
    local config="$1"
    local key="$2"
    echo "$config" | grep -o "$key=[^ ]*" | cut -d= -f2-
}

set -e

# Configuration
PARALLEL_JOBS=${PARALLEL_JOBS:-3}  # Number of parallel jobs (can be overridden)
LOG_DIR="./test-logs"
SWEEP_TIMEOUT="5m"
TEST_TIMEOUT="15m"
TEST_TYPE="acceptance"  # Default test type

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Create log directory
mkdir -p "$LOG_DIR"

# Function to log with timestamp and job ID
log() {
    local job_id="${JOB_ID:-MAIN}"
    echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] [${job_id}] $1"
}

# Function to check if a service has a sweeper by grepping for AddTestSweepers
has_sweeper() {
    local service="$1"
    
    # Look for AddTestSweepers in resource_test.go files
    # We need to check both resource_test.go and any other *_test.go files
    local test_files=("$service"/*_test.go)
    
    for test_file in "${test_files[@]}"; do
        if [ -f "$test_file" ]; then
            # Look for uncommented AddTestSweepers calls
            if grep -q "^[[:space:]]*resource\.AddTestSweepers" "$test_file" 2>/dev/null; then
                return 0
            fi
        fi
    done
    
    return 1
}

# Function to check if a service has migration tests
has_migration_tests() {
    local service="$1"
    
    # Look for TestMigrate functions in test files
    local test_files=("$service"/*_test.go)
    
    for test_file in "${test_files[@]}"; do
        if [ -f "$test_file" ]; then
            # Look for TestMigrate function definitions
            if grep -q "^func TestMigrate" "$test_file" 2>/dev/null; then
                return 0
            fi
        fi
    done
    
    return 1
}

# Function to run sweeper for a service
run_sweeper() {
    local service="$1"
    local parallel_count="$2"
    local log_file="$LOG_DIR/$(basename "$service")-sweeper.log"
    local start_time=$(date +%s)
    
    # Check if this service has a sweeper implementation
    if ! has_sweeper "$service"; then
        log "${YELLOW}Skipping sweeper for $service (no sweeper implemented)${NC}" > "$log_file"
        log "Skipping sweeper for $service (no sweeper implemented)"
        return 0
    fi
    
    log "${WHITE}Sweeping: $service${NC}" > "$log_file"
    log "Sweeping: $service"
    
    # Use the correct sweeper syntax with -sweep-run parameter
    local service_name=$(basename "$service")
    local sweeper_name="cloudflare_${service_name}"
    
    # Build command with optional parallel flag
    local test_cmd="TF_ACC=1 go test -v \"$service\" -sweep=all -sweep-run=\"$sweeper_name\" -timeout \"$SWEEP_TIMEOUT\""
    
    # Add parallel flag if specified and not 0
    if [ "$parallel_count" -gt 0 ]; then
        test_cmd="$test_cmd -parallel $parallel_count"
    fi
    
    if eval "$test_cmd" >> "$log_file" 2>&1; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${GREEN}✓ Sweeper completed: $service (${duration}s total)${NC}" >> "$log_file"
        log "✓ Sweeper completed: $service (${duration}s total)"
        return 0
    else
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${RED}✗ Sweeper failed: $service (${duration}s total) - check $log_file${NC}" >> "$log_file"
        log "✗ Sweeper failed: $service (${duration}s total) - check $log_file"
        return 1
    fi
}

# Function to run tests for a service
run_tests() {
    local service="$1"
    local parallel_count="$2"
    local log_file="$LOG_DIR/$(basename "$service")-tests.log"
    local start_time=$(date +%s)
    local test_pattern test_name
    
    # Set test pattern and name based on test type
    if [ "$TEST_TYPE" = "migration" ]; then
        test_pattern="^TestMigrate"
        test_name="migration tests"
        
        # Check if this service has migration tests
        if ! has_migration_tests "$service"; then
            log "${YELLOW}Skipping $test_name for $service (no migration tests found)${NC}" > "$log_file"
            log "Skipping $test_name for $service (no migration tests found)"
            return 0
        fi
    else
        test_pattern="^TestAcc"
        test_name="acceptance tests"
    fi
    
    log "${WHITE}Running $test_name: $service${NC}" > "$log_file"
    log "Running $test_name: $service"
    
    # Build command with optional parallel flag
    local test_cmd="TF_ACC=1 go test -run \"$test_pattern\" -count 1 -timeout \"$TEST_TIMEOUT\""
    
    # Add parallel flag if specified and not 0
    if [ "$parallel_count" -gt 0 ]; then
        test_cmd="$test_cmd -parallel $parallel_count"
    fi
    
    test_cmd="$test_cmd \"$service\""
    
    if eval "$test_cmd" >> "$log_file" 2>&1; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${GREEN}✓ Tests completed successfully for $service (${duration}s)${NC}" >> "$log_file"
        log "✓ Tests completed successfully for $service (${duration}s)"
        return 0
    else
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${RED}✗ Tests failed for $service (${duration}s) - check $log_file${NC}" >> "$log_file"
        log "✗ Tests failed for $service (${duration}s) - check $log_file"
        return 1
    fi
}

# Function to process a single service (sweeper + tests)
process_service() {
    local service_config="$1"
    
    # Parse service configuration
    local service=$(parse_service_config "$service_config" "resource")
    local parallel_count=$(parse_service_config "$service_config" "parallel")
    
    # Generate unique Job ID for this parallel execution
    local service_name=$(basename "$service")
    # Use nanoseconds if available (Linux), otherwise use seconds + random (macOS/BSD)
    local timestamp
    if date +%s%N >/dev/null 2>&1; then
        timestamp=$(date +%s%N | cut -b1-13)  # milliseconds
    else
        timestamp="$(date +%s)$RANDOM"  # seconds + random number
    fi
    local short_hash=$(echo "$service_name$timestamp" | md5sum 2>/dev/null || echo "$service_name$timestamp" | openssl md5 | cut -d' ' -f2)
    short_hash=$(echo "$short_hash" | cut -c1-6)
    export JOB_ID="J${short_hash}"
    
    local combined_log="$LOG_DIR/${service_name}-combined.log"
    local start_time=$(date +%s)
    
    {
        log "${WHITE}Processing service: $service (parallel=$parallel_count)${NC}"
        
        # Only run sweepers for acceptance tests, not migration tests
        if [ "$TEST_TYPE" != "migration" ]; then
            if ! run_sweeper "$service" "$parallel_count"; then
                log "${YELLOW}Sweeper issues for $service, continuing with tests...${NC}"
            fi
        else
            log "${YELLOW}Skipping sweeper for migration tests: $service${NC}"
        fi
        
        # Run tests
        run_tests "$service" "$parallel_count"
        local test_result=$?
        
        local end_time=$(date +%s)
        local total_duration=$((end_time - start_time))
        
        if [ $test_result -eq 0 ]; then
            log "${GREEN}✓ Completed: $service (${total_duration}s total)${NC}"
        else
            log "${RED}✗ Failed: $service (${total_duration}s total)${NC}"
        fi
        
        return $test_result
    } > "$combined_log" 2>&1
    
    # Always show the result summary (with Job ID for tracking)
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [${JOB_ID}] $(tail -1 "$combined_log" | sed 's/\[[^]]*\] \[MAIN\] //' | sed 's/\[[^]]*\] //')"
    return $?
}

# Export function so it can be used by xargs
export -f process_service run_sweeper run_tests log has_sweeper has_migration_tests parse_service_config
export LOG_DIR SWEEP_TIMEOUT TEST_TIMEOUT TEST_TYPE RED GREEN YELLOW WHITE NC JOB_ID

# Main execution
main() {
    # Set main Job ID for orchestration logs
    export JOB_ID="MAIN"
    
    local start_time=$(date +%s)
    local test_name_display
    
    if [ "$TEST_TYPE" = "migration" ]; then
        test_name_display="migration tests"
    else
        test_name_display="acceptance tests"
    fi
    
    log "${GREEN}Starting parallel CI $test_name_display with $PARALLEL_JOBS jobs${NC}"
    log "${WHITE}Total services to test: ${#SERVICES[@]}${NC}"
    log "${WHITE}Logs will be written to: $LOG_DIR${NC}"
    log "${WHITE}Sweeper timeout: $SWEEP_TIMEOUT, Test timeout: $TEST_TIMEOUT${NC}"
    echo ""
    
    # Clean up old logs
    rm -f "$LOG_DIR"/*.log
    
    log "${WHITE}Running tests with xargs. Real-time output will be shown below:${NC}"
    echo ""
    
    # Start a background job to show progress counts
    (
        export JOB_ID="PROG"
        while sleep 30; do
            completed=$(find "$LOG_DIR" -name "*-combined.log" -exec grep -l "✓ Completed:\|✗ Failed:" {} \; 2>/dev/null | wc -l | tr -d ' ')
            total=${#SERVICES[@]}
            log "${WHITE}Progress: $completed/$total services completed${NC}"
        done
    ) &
    progress_pid=$!
    
    # Start a background job to tail log output and show all detailed progress
    (
        sleep 3  # Give tests a moment to start creating log files
        monitored_list=""
        while true; do
            # Monitor only sweeper and tests log files to get detailed output
            for log_file in "$LOG_DIR"/*-sweeper.log "$LOG_DIR"/*-tests.log; do
                [ -f "$log_file" ] || continue
                # Check if we've already started monitoring this file
                if ! echo "$monitored_list" | grep -q "$log_file"; then
                    monitored_list="$monitored_list $log_file"
                    # Show all content from sweeper and test log files
                    (
                        tail -f "$log_file" 2>/dev/null || true
                    ) &
                fi
            done
            sleep 3
        done
    ) &
    tail_monitor_pid=$!
    
    printf '%s\n' "${SERVICES[@]}" | xargs -I {} -P "$PARALLEL_JOBS" bash -c 'process_service "$@"' _ {}
    parallel_result=$?
    
    # Calculate timing and count results first (outside the atomic block)
    local end_time=$(date +%s)
    local total_duration=$((end_time - start_time))
    local minutes=$((total_duration / 60))
    local seconds=$((total_duration % 60))
    
    # Count results
    local passed=0
    local failed=0
    local failed_list=""
    
    # Temporarily disable exit on error during counting
    set +e
    
    for service_config in "${SERVICES[@]}"; do
        local service=$(parse_service_config "$service_config" "resource")
        local service_name=$(basename "$service")
        local combined_log="$LOG_DIR/${service_name}-combined.log"
        
        if [ -f "$combined_log" ] && grep -q "✓ Completed:" "$combined_log" 2>/dev/null; then
            ((passed++))
        else
            ((failed++))
            failed_list="$failed_list$service "
        fi
    done
    
    # Re-enable exit on error
    set -e
    
    # Stop background processes first to prevent "Terminated" messages
    log "${WHITE}Stopping background monitoring...${NC}"
    kill $progress_pid 2>/dev/null || true
    kill $tail_monitor_pid 2>/dev/null || true
    # Give processes time to exit cleanly
    sleep 2
    # Kill any remaining child processes silently
    pkill -P $tail_monitor_pid >/dev/null 2>&1 || true
    
    # Reset to main Job ID for summary
    export JOB_ID="MAIN"
    
    # Create summary output atomically to minimize interruption window
    {
        echo ""
        log "=== EXECUTION SUMMARY ==="
        log "Total execution time: ${minutes}m ${seconds}s"
        log "Passed: $passed"
        log "Failed: $failed"
        
        if [ $failed -gt 0 ]; then
            echo ""
            log "Failed services:"
            for service in $failed_list; do
                log "  - $service"
            done
            echo ""
            log "Check individual log files in $LOG_DIR for detailed error information"
        fi
        
        log "Summary complete"
    } | cat  # Using cat to force immediate output as a single block
    
    # Final status message - only fail if actual tests failed, not xargs issues
    if [ $failed -gt 0 ]; then
        log "${RED}Some tests failed - see details above${NC}"
        exit 1
    fi
    
    log "${GREEN}All tests completed successfully!${NC}"
}

# Simple cleanup function for any remaining background processes
cleanup() {
    # Quietly clean up any remaining background processes
    jobs -p | xargs -r kill -TERM >/dev/null 2>&1 || true
    pkill -f "tail -f.*$LOG_DIR" >/dev/null 2>&1 || true
    # Give processes a moment to exit
    sleep 1
}

trap cleanup EXIT

# Usage information
if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    echo "Usage: $0 [test-type] [options]"
    echo ""
    echo "Arguments:"
    echo "  test-type          Type of tests to run: 'acceptance' or 'migration' (default: acceptance)"
    echo ""
    echo "Options:"
    echo "  --help, -h         Show this help message"
    echo "  --jobs N           Number of parallel jobs (default: $PARALLEL_JOBS)"
    echo "  --sweep-timeout T  Timeout for sweeper operations (default: $SWEEP_TIMEOUT)"
    echo "  --test-timeout T   Timeout for test operations (default: $TEST_TIMEOUT)"
    echo ""
    echo "Environment variables:"
    echo "  PARALLEL_JOBS      Override default parallel job count"
    echo ""
    echo "Examples:"
    echo "  $0                                    # Run acceptance tests with default settings"
    echo "  $0 migration                         # Run migration tests"
    echo "  $0 acceptance --jobs 4               # Run acceptance tests with 4 parallel jobs"
    echo "  $0 migration --test-timeout 20m      # Run migration tests with 20 minute timeout"
    echo "  PARALLEL_JOBS=8 $0 acceptance        # Run with 8 parallel jobs"
    exit 0
fi

# Parse test type first
if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
    case $1 in
        acceptance|migration)
            TEST_TYPE="$1"
            shift
            ;;
        --dry-run)
            # Keep handling --dry-run as before, but will handle below
            ;;
        *)
            echo "Unknown test type: $1"
            echo "Valid test types: acceptance, migration"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
fi

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            echo "Would run ${#SERVICES[@]} services with $PARALLEL_JOBS parallel jobs ($TEST_TYPE tests)"
            for service_config in "${SERVICES[@]}"; do
                service=$(parse_service_config "$service_config" "resource")
                parallel_count=$(parse_service_config "$service_config" "parallel")
                echo "$service (parallel=$parallel_count)"
            done
            exit 0
            ;;
        --jobs)
            PARALLEL_JOBS="$2"
            shift 2
            ;;
        --sweep-timeout)
            SWEEP_TIMEOUT="$2"
            shift 2
            ;;
        --test-timeout)
            TEST_TIMEOUT="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Validate PARALLEL_JOBS is a number
if ! [[ "$PARALLEL_JOBS" =~ ^[0-9]+$ ]] || [ "$PARALLEL_JOBS" -lt 1 ]; then
    log "${RED}Error: PARALLEL_JOBS must be a positive integer${NC}"
    exit 1
fi

# Run main function
main
