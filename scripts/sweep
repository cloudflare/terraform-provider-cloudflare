#!/usr/bin/env bash

# Account-based sweeper script for Terraform Cloudflare Provider
# This script runs sweepers for all zones under a specified account
# Usage: ./scripts/run-account-sweeper <account_id>

set -e

# Configuration
SWEEP_TIMEOUT="10m"
DEBUG_LOGS=${DEBUG_LOGS:-false}
LOG_DIR="./sweep-logs"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Create log directory
mkdir -p "$LOG_DIR"

# Function to log with timestamp
log() {
    echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Function for debug logging (only outputs when DEBUG_LOGS=true)
debug_log() {
    if [ "$DEBUG_LOGS" = "true" ]; then
        log "$1"
    fi
}

# Usage information
show_usage() {
    echo "Usage: $0 --account <account_id> [options]"
    echo "       $0 [options]               (uses CLOUDFLARE_ACCOUNT_ID env var)"
    echo "       $0 <account_id> [options]  (legacy format)"
    echo "       $0 --list                  (list available sweepers)"
    echo ""
    echo "Arguments:"
    echo "  --account ID       Cloudflare Account ID to sweep resources for (optional if CLOUDFLARE_ACCOUNT_ID is set)"
    echo ""
    echo "Options:"
    echo "  --help, -h                      Show this help message"
    echo "  --list                          List all available sweepers and exit"
    echo "  --zone ID                       Target a specific zone ID (filters zone-level sweepers)"
    echo "  --resource NAME                 Target a specific resource type (e.g., load_balancer, dns_record)"
    echo "  --sweep-timeout T               Timeout for sweeper operations (default: $SWEEP_TIMEOUT)"
    echo "  --debug                         Enable debug logging (default: disabled)"
    echo "  --dry-run                       Show what would be swept without executing"
    echo "  --dangerously-delete-resources  DANGEROUS: Skip resource name validation and delete ALL resources"
    echo ""
    echo "Environment variables (authentication):"
    echo "  CLOUDFLARE_API_TOKEN              Your Cloudflare API token"
    echo "  OR"
    echo "  CLOUDFLARE_API_KEY + CLOUDFLARE_EMAIL   Your Cloudflare API key and email"
    echo ""
    echo "Environment variables (optional defaults):"
    echo "  CLOUDFLARE_ACCOUNT_ID             Default account ID (used when --account not specified)"
    echo "  CLOUDFLARE_ZONE_ID                Default zone ID (used when --zone not specified)"
    echo ""
    echo "Other environment variables:"
    echo "  DEBUG_LOGS                        Enable debug logging (default: false)"
    echo "  SWEEP_DANGEROUSLY_DELETE_ALL      Set by --dangerously-delete-resources flag"
    echo ""
    echo "Examples:"
    echo "  $0 --list"
    echo "  $0 --account c03814971cc44525d34173ca738b615b"
    echo "  $0 --account c03814971cc44525d34173ca738b615b --debug"
    echo "  $0 --account c03814971cc44525d34173ca738b615b --resource load_balancer"
    echo "  $0 --account c03814971cc44525d34173ca738b615b --zone 32b08b824a1707e468c6e839df23e57f --resource ruleset"
    echo "  $0 --account c03814971cc44525d34173ca738b615b --sweep-timeout 15m"
    echo "  $0 c03814971cc44525d34173ca738b615b --resource dns_record --debug  # Legacy format"
    echo "  DEBUG_LOGS=true $0 --account c03814971cc44525d34173ca738b615b"
    echo ""
    echo "  # Using environment variables:"
    echo "  export CLOUDFLARE_ACCOUNT_ID=c03814971cc44525d34173ca738b615b"
    echo "  $0 --resource load_balancer"
    echo "  $0 --zone 32b08b824a1707e468c6e839df23e57f --resource ruleset"
    echo ""
    echo "  ${RED}DANGEROUS EXAMPLE:${NC}"
    echo "  $0 --account c03814971cc44525d34173ca738b615b --dangerously-delete-resources --resource dns_record"
    exit 0
}

# Function to check if a resource is account-level
is_account_level_resource() {
    local resource="$1"
    local account_services
    account_services=$(get_account_level_services)
    
    echo "$account_services" | grep -q "^$resource$"
}

# Function to check if a resource is zone-level
is_zone_level_resource() {
    local resource="$1"
    local zone_services
    zone_services=$(get_zone_level_services)
    
    echo "$zone_services" | grep -q "^$resource$"
}

# Function to validate prerequisites
validate_prerequisites() {
    local account_id="$1"
    local target_resource="$2"
    
    # Check if account_id is provided and looks like a valid Cloudflare account ID
    if [ -z "$account_id" ]; then
        log "${RED}Error: Account ID is required${NC}"
        show_usage
    fi
    
    # Validate account ID format (32 character hex string)
    if ! [[ "$account_id" =~ ^[a-f0-9]{32}$ ]]; then
        log "${RED}Error: Account ID should be a 32-character hexadecimal string${NC}"
        exit 1
    fi
    
    # Validate target zone format if specified (32 character hex string)
    if [ -n "$TARGET_ZONE" ] && ! [[ "$TARGET_ZONE" =~ ^[a-f0-9]{32}$ ]]; then
        log "${RED}Error: Zone ID should be a 32-character hexadecimal string${NC}"
        exit 1
    fi
    
    # Validate target resource if specified
    if [ -n "$target_resource" ]; then
        if ! is_account_level_resource "$target_resource" && ! is_zone_level_resource "$target_resource"; then
            log "${RED}Error: Unknown resource type '$target_resource'${NC}"
            log "${WHITE}Available account-level resources:${NC}"
            get_account_level_services | sed 's/^/  /'
            log "${WHITE}Available zone-level resources:${NC}"
            get_zone_level_services | sed 's/^/  /'
            exit 1
        fi
        
        # Check if the resource has a sweeper
        if ! has_sweeper "$target_resource"; then
            log "${RED}Error: Resource '$target_resource' does not have a sweeper implementation${NC}"
            exit 1
        fi
        
        log "${GREEN}Target resource '$target_resource' validated${NC}"
    fi
    
    # Check if either CLOUDFLARE_API_TOKEN or (CLOUDFLARE_API_KEY + CLOUDFLARE_EMAIL) is set
    if [ -z "$CLOUDFLARE_API_TOKEN" ] && [ -z "$CLOUDFLARE_API_KEY" ]; then
        log "${RED}Error: Either CLOUDFLARE_API_TOKEN or CLOUDFLARE_API_KEY + CLOUDFLARE_EMAIL environment variables are required${NC}"
        exit 1
    fi

    # If using API key, ensure email is also set
    if [ -n "$CLOUDFLARE_API_KEY" ] && [ -z "$CLOUDFLARE_EMAIL" ]; then
        log "${RED}Error: CLOUDFLARE_EMAIL is required when using CLOUDFLARE_API_KEY${NC}"
        exit 1
    fi
    
    # Check if curl is available for API calls
    if ! command -v curl >/dev/null 2>&1; then
        log "${RED}Error: curl is required but not installed${NC}"
        exit 1
    fi
    
    # Check if jq is available for JSON parsing
    if ! command -v jq >/dev/null 2>&1; then
        log "${RED}Error: jq is required but not installed${NC}"
        exit 1
    fi
    
    # Check if go is available
    if ! command -v go >/dev/null 2>&1; then
        log "${RED}Error: go is required but not installed${NC}"
        exit 1
    fi
    
    log "${GREEN}Prerequisites validated successfully${NC}"
}

# Function to fetch zones for an account using Cloudflare API
fetch_zones_for_account() {
    local account_id="$1"
    local zones_file="$LOG_DIR/zones_${account_id}.json"
    
    log "${WHITE}Fetching zones for account: $account_id${NC}" >&2

    # Build authentication headers based on available credentials
    local auth_headers
    if [ -n "$CLOUDFLARE_API_TOKEN" ]; then
        auth_headers="-H \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\""
    else
        auth_headers="-H \"X-Auth-Email: $CLOUDFLARE_EMAIL\" -H \"X-Auth-Key: $CLOUDFLARE_API_KEY\""
    fi

    # Make API request to list zones for the account
    local api_response=$(eval curl -s -X GET "https://api.cloudflare.com/client/v4/zones?account.id=${account_id}" \
        $auth_headers \
        -H "Content-Type: application/json")
    
    # Check if we got any response
    if [ -z "$api_response" ]; then
        log "${RED}Error: No response from Cloudflare API${NC}" >&2
        exit 1
    fi
    
    # Check if the response is valid JSON and successful
    local success=$(echo "$api_response" | jq -r '.success // false' 2>/dev/null)
    if [ "$success" != "true" ]; then
        local errors=$(echo "$api_response" | jq -r '.errors[]?.message // "Unknown error"' 2>/dev/null || echo "Invalid API response")
        log "${RED}Error fetching zones from Cloudflare API: $errors${NC}" >&2
        debug_log "${WHITE}API Response: $api_response${NC}" >&2
        # Create empty zones file and return it instead of exiting
        echo "[]" > "$zones_file"
        echo "$zones_file"
        return
    fi
    
    # Save zones to file and ensure it's written before continuing
    echo "$api_response" | jq '.result' > "$zones_file"
    
    # Verify the file was created and is readable
    if [ ! -f "$zones_file" ]; then
        log "${RED}Error: Failed to create zones file: $zones_file${NC}" >&2
        exit 1
    fi
    
    # Count zones
    local zone_count=$(jq length "$zones_file" 2>/dev/null || echo "0")
    log "${GREEN}Found $zone_count zones for account $account_id${NC}" >&2
    
    if [ "$DEBUG_LOGS" = "true" ] && [ "$zone_count" -gt 0 ]; then
        log "${WHITE}Zone IDs:${NC}" >&2
        jq -r '.[].id' "$zones_file" 2>/dev/null | while read -r zone_id; do
            local zone_name=$(jq -r ".[] | select(.id==\"$zone_id\") | .name" "$zones_file" 2>/dev/null || echo "unknown")
            log "  - $zone_id ($zone_name)" >&2
        done
    fi
    
    echo "$zones_file"
}

# Cache for discovered services (to avoid repeated discovery)
ACCOUNT_SERVICES_CACHE=""
ZONE_SERVICES_CACHE=""
DISCOVERY_DONE="false"

# Function to discover all available services with sweepers
discover_sweepers() {
    if [ "$DISCOVERY_DONE" = "true" ]; then
        return 0
    fi

    debug_log "${WHITE}Discovering available sweepers...${NC}"

    local account_services=()
    local zone_services=()

    # Scan all service directories
    for service_dir in ./internal/services/*/; do
        if [ ! -d "$service_dir" ]; then
            continue
        fi

        local service=$(basename "$service_dir")

        # Check if this service has a sweeper
        if ! has_sweeper "$service"; then
            continue
        fi

        # Check which type of sweeper it is by examining the test files
        local is_account=false
        local is_zone=false

        # Look for CLOUDFLARE_ACCOUNT_ID and CLOUDFLARE_ZONE_ID usage in test files
        for test_file in "$service_dir"/*_test.go; do
            if [ ! -f "$test_file" ]; then
                continue
            fi

            # Check if the sweeper function references CLOUDFLARE_ACCOUNT_ID
            if grep -q 'CLOUDFLARE_ACCOUNT_ID' "$test_file" 2>/dev/null; then
                is_account=true
            fi

            # Check if the sweeper function references CLOUDFLARE_ZONE_ID
            if grep -q 'CLOUDFLARE_ZONE_ID' "$test_file" 2>/dev/null; then
                is_zone=true
            fi
        done

        # Add to appropriate list(s)
        if [ "$is_account" = "true" ]; then
            account_services+=("$service")
        fi

        if [ "$is_zone" = "true" ]; then
            zone_services+=("$service")
        fi
    done

    # Sort the services alphabetically
    ACCOUNT_SERVICES_CACHE=$(printf '%s\n' "${account_services[@]}" | sort)
    ZONE_SERVICES_CACHE=$(printf '%s\n' "${zone_services[@]}" | sort)
    DISCOVERY_DONE="true"

    debug_log "${GREEN}Discovery complete. Found $(echo "$ACCOUNT_SERVICES_CACHE" | wc -w) account-level and $(echo "$ZONE_SERVICES_CACHE" | wc -w) zone-level sweepers.${NC}"
}

# Get account-level services (discovers on first call, then uses cache)
get_account_level_services() {
    discover_sweepers
    echo "$ACCOUNT_SERVICES_CACHE"
}

# Get zone-level services (discovers on first call, then uses cache)
get_zone_level_services() {
    discover_sweepers
    echo "$ZONE_SERVICES_CACHE"
}

# Function to check if a service has a sweeper implementation
has_sweeper() {
    local service="$1"
    local service_path="./internal/services/$service"
    
    # Look for AddTestSweepers in test files
    local test_files=("$service_path"/*_test.go)
    
    for test_file in "${test_files[@]}"; do
        if [ -f "$test_file" ]; then
            # Look for uncommented AddTestSweepers calls
            if grep -q "^[[:space:]]*resource\.AddTestSweepers" "$test_file" 2>/dev/null; then
                return 0
            fi
        fi
    done
    
    return 1
}

# Function to run sweeper for a service
run_sweeper() {
    local service="$1"
    local account_id="$2"
    local zone_id="$3"  # Optional, empty for account-level services
    local log_file="$LOG_DIR/${service}-sweeper.log"
    local start_time=$(date +%s)
    
    # Check if this service has a sweeper implementation
    if ! has_sweeper "$service"; then
        log "${YELLOW}Skipping sweeper for $service (no sweeper implemented)${NC}"
        return 0
    fi
    
    # Set environment variables
    export CLOUDFLARE_ACCOUNT_ID="$account_id"
    if [ -n "$zone_id" ]; then
        export CLOUDFLARE_ZONE_ID="$zone_id"
        log "${WHITE}Sweeping zone-level service: $service (zone: $zone_id)${NC}"
    else
        log "${WHITE}Sweeping account-level service: $service (account: $account_id)${NC}"
    fi

    # Export the danger flag if set (sweepers can check this)
    if [ "$DANGEROUSLY_DELETE_ALL" = "true" ]; then
        export SWEEP_DANGEROUSLY_DELETE_ALL="true"
    fi
    
    # Build sweeper command
    local service_path="./internal/services/$service"
    local sweeper_name="cloudflare_${service}"
    # NOTE: Do NOT set TF_ACC=1 when running sweepers, as that triggers acceptance tests
    local test_cmd="go test -v \"$service_path\" -sweep=all -sweep-run=\"$sweeper_name\" -timeout \"$SWEEP_TIMEOUT\""
    
    debug_log "${WHITE}Running command: $test_cmd${NC}"
    
    # Run the sweeper command
    # Use tee to output to both stdout and log file
    log "Running sweeper..." > "$log_file"
    if eval "$test_cmd" 2>&1 | tee -a "$log_file"; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${GREEN}✓ Sweeper completed: $service (${duration}s)${NC}"
        return 0
    else
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        log "${RED}✗ Sweeper failed: $service (${duration}s) - check $log_file${NC}"
        return 1
    fi
}

# Function to run account-level sweepers
run_account_sweepers() {
    local account_id="$1"
    local dry_run="$2"
    local target_resource="$3"
    
    log "${WHITE}=== Running Account-Level Sweepers ===${NC}"
    
    local account_services
    if [ -n "$target_resource" ]; then
        # Only run the specific target resource if it's account-level
        if is_account_level_resource "$target_resource"; then
            account_services="$target_resource"
            log "${WHITE}Targeting specific account-level resource: $target_resource${NC}"
        else
            log "${WHITE}Target resource '$target_resource' is not account-level, skipping account sweepers${NC}"
            echo ""
            return
        fi
    else
        account_services=$(get_account_level_services)
    fi
    
    local total=0
    local success=0
    local failed=0
    
    for service in $account_services; do
        if ! has_sweeper "$service"; then
            debug_log "Skipping $service (no sweeper)"
            continue
        fi
        
        total=$((total + 1))
        
        if [ "$dry_run" = "true" ]; then
            log "${WHITE}[DRY-RUN] Would sweep account-level service: $service${NC}"
            continue
        fi
        
        if run_sweeper "$service" "$account_id" ""; then
            success=$((success + 1))
        else
            failed=$((failed + 1))
        fi
    done
    
    if [ "$dry_run" != "true" ]; then
        log "${WHITE}Account sweepers complete: $success success, $failed failed (of $total total)${NC}"
    else
        log "${WHITE}[DRY-RUN] Would run $total account-level sweepers${NC}"
    fi
    echo ""
}

# Function to run zone-level sweepers
run_zone_sweepers() {
    local account_id="$1" 
    local zones_file="$2"
    local dry_run="$3"
    local target_resource="$4"
    local target_zone="$5"
    
    log "${WHITE}=== Running Zone-Level Sweepers ===${NC}"
    
    local zone_services
    if [ -n "$target_resource" ]; then
        # Only run the specific target resource if it's zone-level
        if is_zone_level_resource "$target_resource"; then
            zone_services="$target_resource"
            log "${WHITE}Targeting specific zone-level resource: $target_resource${NC}"
        else
            log "${WHITE}Target resource '$target_resource' is not zone-level, skipping zone sweepers${NC}"
            return
        fi
    else
        zone_services=$(get_zone_level_services)
    fi
    
    # Get zone count
    local zone_count=$(jq length "$zones_file" 2>/dev/null || echo "0")
    
    if [ -z "$zone_count" ]; then
        log "${RED}Error: zone_count is empty, zones_file='$zones_file'${NC}"
        zone_count=0
    fi
    
    if [ "$zone_count" -eq 0 ]; then
        log "${YELLOW}No zones found for account $account_id${NC}"
        return
    fi
    
    local total_sweeps=0
    local successful_sweeps=0
    local failed_sweeps=0
    
    # Process each zone
    for ((i = 0; i < zone_count; i++)); do
        local zone_id=$(jq -r ".[$i].id" "$zones_file")
        local zone_name=$(jq -r ".[$i].name" "$zones_file")
        
        # Skip zones not matching target zone if specified
        if [ -n "$target_zone" ] && [ "$zone_id" != "$target_zone" ]; then
            debug_log "Skipping zone $zone_name ($zone_id) - not matching target zone $target_zone"
            continue
        fi
        
        log "${WHITE}Processing zone: $zone_name ($zone_id)${NC}"
        
        for service in $zone_services; do
            if ! has_sweeper "$service"; then
                debug_log "Skipping $service (no sweeper)"
                continue
            fi
            
            total_sweeps=$((total_sweeps + 1))
            
            if [ "$dry_run" = "true" ]; then
                log "${WHITE}[DRY-RUN] Would sweep zone-level service: $service for zone $zone_name${NC}"
                continue
            fi
            
            if run_sweeper "$service" "$account_id" "$zone_id"; then
                successful_sweeps=$((successful_sweeps + 1))
            else
                failed_sweeps=$((failed_sweeps + 1))
            fi
        done
        
        if [ "$dry_run" != "true" ]; then
            echo ""
        fi
    done
    
    if [ "$dry_run" != "true" ]; then
        if [ -n "$target_resource" ]; then
            log "${WHITE}Zone sweepers complete for '$target_resource': $successful_sweeps success, $failed_sweeps failed (across $zone_count zones)${NC}"
        else
            log "${WHITE}Zone sweepers complete: $successful_sweeps success, $failed_sweeps failed (of $total_sweeps total across $zone_count zones)${NC}"
        fi
    else
        if [ -n "$target_resource" ]; then
            log "${WHITE}[DRY-RUN] Would sweep '$target_resource' for $zone_count zones${NC}"
        else
            log "${WHITE}[DRY-RUN] Would run sweepers for $zone_count zones${NC}"
        fi
    fi
}

# Function to display available sweepers
display_available_sweepers() {
    log "${WHITE}Available account-level resources:${NC}"
    get_account_level_services | sed 's/^/  /'

    log "${WHITE}Available zone-level resources:${NC}"
    get_zone_level_services | sed 's/^/  /'
}

# Main execution function
main() {
    local account_id="$1"
    local dry_run="$2"
    local target_resource="$3"
    local target_zone="$4"
    local start_time=$(date +%s)

    log "${GREEN}Starting account-based sweeper for account: $account_id${NC}"
    if [ -n "$target_resource" ]; then
        log "${WHITE}Targeting specific resource: $target_resource${NC}"
    fi
    if [ "$dry_run" = "true" ]; then
        log "${YELLOW}DRY-RUN MODE: No sweepers will be executed${NC}"
    fi
    if [ "$DANGEROUSLY_DELETE_ALL" = "true" ]; then
        log "${RED}⚠️  DANGER MODE ENABLED: Resource name validation is DISABLED${NC}"
        log "${RED}⚠️  ALL RESOURCES will be deleted, regardless of their names!${NC}"
        log "${RED}⚠️  This may delete production resources. Proceed with extreme caution!${NC}"
        sleep 2  # Give user time to see the warning
    fi
    log "${WHITE}Logs will be written to: $LOG_DIR${NC}"
    log "${WHITE}Sweeper timeout: $SWEEP_TIMEOUT${NC}"

    # Display available sweepers if in debug mode
    if [ "$DEBUG_LOGS" = "true" ]; then
        echo ""
        display_available_sweepers
    fi

    echo ""
    
    # Clean up old logs
    rm -f "$LOG_DIR"/*.log "$LOG_DIR"/zones_*.json
    
    # Determine if we need to fetch zones
    local need_zones=true
    local zones_file=""
    local zone_count=0
    
    if [ -n "$target_resource" ] && is_account_level_resource "$target_resource"; then
        # If targeting only an account-level resource, no need to fetch zones
        log "${WHITE}Target resource is account-level only, skipping zone fetch${NC}"
        need_zones=false
        zone_count=0
        echo ""
    elif [ -n "$target_zone" ]; then
        # If targeting a specific zone, create a minimal zones file with just that zone
        log "${WHITE}Targeting specific zone: $target_zone${NC}"
        zones_file="$LOG_DIR/zones_${account_id}.json"
        # Create a minimal zones file with just the target zone
        echo "[{\"id\":\"$target_zone\",\"name\":\"target-zone\"}]" > "$zones_file"
        zone_count=1
        echo ""
    else
        # Fetch zones for the account
        zones_file=$(fetch_zones_for_account "$account_id")
        debug_log "${WHITE}fetch_zones_for_account returned: '$zones_file'${NC}"
        debug_log "${WHITE}File exists check: [ -f '$zones_file' ] = $([ -f "$zones_file" ] && echo 'true' || echo 'false')${NC}"
        if [ -n "$zones_file" ] && [ -f "$zones_file" ]; then
            zone_count=$(jq length "$zones_file" 2>/dev/null || echo "0")
            debug_log "${WHITE}Zone count from jq: '$zone_count'${NC}"
        else
            log "${RED}Error: Zones file not created properly${NC}"
            log "${RED}zones_file='$zones_file', exists=$([ -f "$zones_file" ] && echo 'yes' || echo 'no')${NC}"
            zone_count=0
        fi
        echo ""
    fi
    
    # Run account-level sweepers first
    run_account_sweepers "$account_id" "$dry_run" "$target_resource"
    
    # Run zone-level sweepers for each zone (only if we have zones or need to run zone sweepers)
    if [ "$need_zones" = "true" ]; then
        run_zone_sweepers "$account_id" "$zones_file" "$dry_run" "$target_resource" "$target_zone"
    fi
    
    # Final summary
    local end_time=$(date +%s)
    local total_duration=$((end_time - start_time))
    local minutes=$((total_duration / 60))
    local seconds=$((total_duration % 60))
    
    echo ""
    log "=== FINAL SUMMARY ==="
    log "Total execution time: ${minutes}m ${seconds}s"
    log "Account ID: $account_id"
    log "Zones processed: $zone_count"
    if [ "$dry_run" != "true" ]; then
        log "Check individual log files in $LOG_DIR for detailed results"
    fi
    
    if [ "$dry_run" != "true" ]; then
        log "${GREEN}Account sweep completed!${NC}"
    else
        log "${GREEN}Dry run completed!${NC}"
    fi
}

# Parse command line arguments
ACCOUNT_ID=""
DRY_RUN="false"
TARGET_RESOURCE=""
TARGET_ZONE=""
LIST_ONLY="false"
DANGEROUSLY_DELETE_ALL="false"

while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            show_usage
            ;;
        --list)
            LIST_ONLY="true"
            shift
            ;;
        --account)
            ACCOUNT_ID="$2"
            shift 2
            ;;
        --zone)
            TARGET_ZONE="$2"
            shift 2
            ;;
        --resource)
            TARGET_RESOURCE="$2"
            shift 2
            ;;
        --sweep-timeout)
            SWEEP_TIMEOUT="$2"
            shift 2
            ;;
        --debug)
            DEBUG_LOGS="true"
            shift
            ;;
        --dry-run)
            DRY_RUN="true"
            shift
            ;;
        --dangerously-delete-resources)
            DANGEROUSLY_DELETE_ALL="true"
            shift
            ;;
        *)
            if [ -z "$ACCOUNT_ID" ]; then
                ACCOUNT_ID="$1"  # Legacy format support
            else
                log "${RED}Error: Unknown argument '$1'${NC}"
                show_usage
            fi
            shift
            ;;
    esac
done

# Handle --list option
if [ "$LIST_ONLY" = "true" ]; then
    display_available_sweepers
    exit 0
fi

# Use environment variables as defaults if not provided via command line
if [ -z "$ACCOUNT_ID" ] && [ -n "$CLOUDFLARE_ACCOUNT_ID" ]; then
    ACCOUNT_ID="$CLOUDFLARE_ACCOUNT_ID"
    log "${WHITE}Using CLOUDFLARE_ACCOUNT_ID from environment: $ACCOUNT_ID${NC}"
fi

if [ -z "$TARGET_ZONE" ] && [ -n "$CLOUDFLARE_ZONE_ID" ]; then
    TARGET_ZONE="$CLOUDFLARE_ZONE_ID"
    log "${WHITE}Using CLOUDFLARE_ZONE_ID from environment: $TARGET_ZONE${NC}"
fi

# Validate arguments and prerequisites
validate_prerequisites "$ACCOUNT_ID" "$TARGET_RESOURCE"

# Run main function
main "$ACCOUNT_ID" "$DRY_RUN" "$TARGET_RESOURCE" "$TARGET_ZONE"